#!/usr/bin/env python3
"""
CCA2 Bit‑Oracle Attack Demo (after Knockel–Ristenpart–Crandall 2018 §4.1)
=======================================================================

This script simulates QQ Browser 6.5 (Android) encryption protocol and
implements the corresponding *chosen‑ciphertext (CCA2) attack* on textbook
RSA.  It works with the RSA keys generated by ``textbook_rsa_assignment.py``.

Two sub‑commands are available:

* ``python cca2_attack_demo.py setup``
    – act as the **victim client**.  Generate an AES‑128 session key using a
      PRNG seeded with *time‑of‑day in ms*, encrypt a WUP request, and write
      the artefacts required:

      ├── AES_Key.txt              (hex)
      ├── WUP_Request.txt          (hex)
      ├── AES_Encrypted_WUP.txt    (hex)
      └── History_Message.txt      (cipher_RSA_hex \n cipher_AES_hex)

* ``python cca2_attack_demo.py attack``
    – act as the **active attacker**.  Run the 128‑query bit‑oracle attack to
      recover the AES key from *History_Message.txt*, then decrypt the
      captured WUP request.

External dependency: ``pycryptodome`` (install via *pip install pycryptodome*).
"""

from __future__ import annotations

import json
import os
import random
import sys
import time
from typing import Tuple

from Crypto.Cipher import AES  # type: ignore
from Crypto.Util.Padding import pad, unpad

from textbook_rsa_assignment import encrypt, int_from_bytes, int_to_bytes

# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------

def read_int(path: str) -> int:
    """Read a decimal integer from a text file."""
    return int(open(path, "r").read().strip())


def aes_encrypt_ecb(key: bytes, data: bytes) -> bytes:
    return AES.new(key, AES.MODE_ECB).encrypt(pad(data, 16))


def aes_decrypt_ecb(key: bytes, ct: bytes) -> bytes:
    return unpad(AES.new(key, AES.MODE_ECB).decrypt(ct), 16)


# ------------------------------------------------------------
# Oracle (simulated server)
# ------------------------------------------------------------

class Oracle:
    """Simulate QQ Browser server side logic.

    *   Decrypt RSA with secret key, keep **least‑significant 128 bits** as
        session key.
    *   Attempt AES‑ECB decryption of the provided ciphertext.
    *   Return *True* iff the result parses as valid JSON (≙ "server replied").
    """

    def __init__(self, d: int, n: int):
        self.d = d
        self.n = n

    def query(self, C_prime: int, aes_ct_hex: str) -> bool:
        # 1. textbook‑RSA decryption
        m = pow(C_prime, self.d, self.n)
        k_bytes = int_to_bytes(m, length=(self.n.bit_length() + 7) // 8)[-16:]
        # 2. AES decrypt + JSON check
        try:
            pt = aes_decrypt_ecb(k_bytes, bytes.fromhex(aes_ct_hex))
            json.loads(pt.decode())  # raise if not valid UTF‑8 / JSON
            return True
        except Exception:
            return False


# ------------------------------------------------------------
# Victim‑client setup phase
# ------------------------------------------------------------

def setup_phase() -> None:
    print("[SETUP] Loading RSA parameters …")
    n = read_int("RSA_Moduler.txt")
    e = read_int("RSA_Public_Key.txt")

    # 1. Generate AES‑128 key using PRNG seeded with current time (ms)
    seed_ms = int(time.time() * 1000)
    rng = random.Random(seed_ms)
    k_int = rng.getrandbits(128)
    k_bytes = k_int.to_bytes(16, "big")
    print(f"[SETUP] AES key (from PRNG seeded {seed_ms}):", k_bytes.hex())

    # 2. Craft a minimal WUP request
    wup_obj = {
        "imei": "990000862471854",
        "url": "https://example.com",
        "ts": int(time.time())
    }
    wup_plain = json.dumps(wup_obj, separators=(",", ":")).encode()
    wup_ct = aes_encrypt_ecb(k_bytes, wup_plain)

    # 3. Encrypt AES key with textbook RSA
    C_int = encrypt(int_from_bytes(k_bytes), e, n)

    # 4. Write artefacts for grading
    open("AES_Key.txt", "w").write(k_bytes.hex())
    open("WUP_Request.txt", "w").write(wup_plain.hex())
    open("AES_Encrypted_WUP.txt", "w").write(wup_ct.hex())
    with open("History_Message.txt", "w") as f:
        f.write(hex(C_int)[2:] + "\n" + wup_ct.hex())

    print("[SETUP] Files generated: History_Message.txt etc.")


# ------------------------------------------------------------
# CCA2 attack phase
# ------------------------------------------------------------

def attack_phase() -> None:
    print("[ATTACK] Loading data …")
    n = read_int("RSA_Moduler.txt")
    e = read_int("RSA_Public_Key.txt")
    d = read_int("RSA_Secret_Key.txt")

    with open("History_Message.txt", "r") as f:
        C_hex = f.readline().strip()
        victim_ct_hex = f.readline().strip()
    C_orig = int(C_hex, 16)

    oracle = Oracle(d, n)

    # Constant WUP plaintext we will reuse for all oracle queries
    attack_wup_plain = b"{\"ok\":true}"

    # Pre‑compute 2^e (mod n) once
    two_pow_e_mod_n = pow(2, e, n)

    recovered_bits = 0  # holds bits of *original* AES key as we learn them
    print("[ATTACK] Starting 128‑query bit‑oracle attack …")

    queries = 0
    for i in range(128):  # recover k[0] .. k[127]
        b_shift = 127 - i  # C_b = Enc( 2^{b} ⋅ k )
        C_b = (C_orig * pow(two_pow_e_mod_n, b_shift, n)) % n

        # ---- try guess 0 ----
        k_guess0 = recovered_bits  # bit i set to 0 implicitly
        stub0 = ((k_guess0) << b_shift) & ((1 << 128) - 1)
        ct0_hex = aes_encrypt_ecb(stub0.to_bytes(16, "big"), attack_wup_plain).hex()
        success = oracle.query(C_b, ct0_hex)
        queries += 1

        if success:
            bit = 0
        else:
            # ---- guess must be 1 ----
            bit = 1
            recovered_bits |= 1 << i
        print(f"    recovered k[{i:3}] = {bit}")

    # Assemble recovered AES key
    recovered_key_bytes = recovered_bits.to_bytes(16, "big")
    print("[ATTACK] Recovered AES key:", recovered_key_bytes.hex())
    open("Recovered_AES_Key.txt", "w").write(recovered_key_bytes.hex())

    # Verify by decrypting victim's WUP
    try:
        wup_plain = aes_decrypt_ecb(recovered_key_bytes, bytes.fromhex(victim_ct_hex))
        print("[ATTACK] Successfully decrypted victim WUP →", wup_plain.decode())
    except Exception as exc:
        print("[ATTACK] Verification failed:", exc)

    print("[ATTACK] Total oracle queries:", queries)


# ------------------------------------------------------------

if __name__ == "__main__":
    if len(sys.argv) != 2 or sys.argv[1] not in {"setup", "attack"}:
        print("Usage: python cca2_attack_demo.py [setup|attack]")
        sys.exit(1)

    if sys.argv[1] == "setup":
        setup_phase()
    else:
        attack_phase()
